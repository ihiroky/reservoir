package net.ihiroky.reservoir.coder;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import net.ihiroky.reservoir.Cache;
import net.ihiroky.reservoir.StreamingCoder;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * A base implementation of {@link net.ihiroky.reservoir.StreamingCoder} to handle with JSON.
 * The JSON format generated by {@code JSONCoder}, follows listed below, for a cache,
 * {@code kn} is a key in the cache and {@code kv} is a mapped value for {@code kn}:
 *
 * <pre>
 *     [{"k":k1,"v":v1},{"k":k2,v2}, ... ,{"k":kn,"v":vn}]
 * </pre>
 *
 * Any primitive types, String, BigInteger and BigDecimal are acceptable according to JSON types.
 * The other Object types must be serializable or serialized to valid format expressed in JSON.
 * These rule is required to define by a sub class using {@link net.ihiroky.reservoir.coder.JSONCoder.JsonWriter}
 * and {@link net.ihiroky.reservoir.coder.JSONCoder.JsonReader}.
 *
 * Supported charset is UTF-8 only.
 *
 * @param <K> the type of keys
 * @param <V> the type of mapped values
 * @author Hiroki Itoh
 */
public abstract class JSONCoder<K, V> implements StreamingCoder<K, V> {

    private JsonFactory jsonFactory;

    private static final Charset CHARSET = Charset.forName("UTF-8");

    private static final String KEY = "k";
    private static final String VALUE = "v";

    private static final JSONCoder<String, String> STRING_CODER = new JSONCoder<String, String>() {
        @Override
        protected void writeKey(JsonWriter writer, String key) throws Exception {
            writer.setString(key);
        }

        @Override
        protected void writeValue(JsonWriter writer, String value) throws Exception {
            writer.setString(value);
        }

        @Override
        protected String readKey(JsonReader reader) throws Exception {
            return reader.getString();
        }

        @Override
        protected String readValue(JsonReader reader) throws Exception {
            return reader.getString();
        }

        @Override
        protected String toKeyString(String key) throws Exception {
            return key;
        }

        @Override
        protected String toKey(String key) throws Exception {
            return key;
        }
    };

    /**
     * Returns {@code JSONCoder} that codes a cache which type of the key and value are {@code String}.
     *
     * @return {@code JSONCoder} that codes a cache which type of the key and value are {@code String}
     */
    public static JSONCoder<String, String> getStringCoder() {
        return STRING_CODER;
    }

    /**
     * Constructs a new {@code JSONCoder}.
     */
    protected JSONCoder() {
        jsonFactory = new JsonFactory();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void write(String key, Cache<K, V> cache, OutputStream outputStream) throws Exception {
        K k = toKey(key);
        write(k, cache.get(k), outputStream);
    }

    /**
     * Writes {@code key} and {@code value} into an {@code outputStream} with JSON format.
     *
     * @param key a key of an entry
     * @param value a value of an entry
     * @param outputStream stream that the {@code key} and {@code value} are written into
     * @throws Exception if the {@code outputStream}
     */
    private void write(K key, V value, OutputStream outputStream) throws Exception {
        JsonGenerator generator =
                jsonFactory.createJsonGenerator(new OutputStreamWriter(outputStream, CHARSET));
        generator.writeStartArray();
        if (value != null) {
            JsonWriter writer = new JsonWriter(generator);
            generator.writeStartObject();
            generator.writeFieldName(KEY);
            writeKey(writer, key);
            generator.writeFieldName(VALUE);
            writeValue(writer, value);
            generator.writeEndObject();
        }
        generator.writeEndArray();
        generator.flush();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void write(Pattern pattern, Cache<K, V> cache, OutputStream outputStream) throws Exception {
        write(pattern, cache, outputStream, false);
    }

    /**
     * Writes keys that is matched by a regular expression and the mapped {@code value}s
     * to a specified {@code outputStream}.
     *
     * @param pattern a regular expression which matches keys to be written
     * @param cache a cache that holds keys matched by {@code pattern} and mapped value by the keys
     * @param outputStream a stream witch matched keys and the mapped value are written into
     * @param removeIfMatched true if entries that have matched keys is delete from the {@code cache}
     * @throws Exception if some error occurs
     */
    private void write(Pattern pattern, Cache<K, V> cache, OutputStream outputStream,
                       boolean removeIfMatched) throws Exception {
        JsonGenerator generator =
                jsonFactory.createJsonGenerator(new OutputStreamWriter(outputStream, CHARSET));
        JsonWriter writer = new JsonWriter(generator);
        generator.writeStartArray();
        Map.Entry<K, V> entry;
        K key;
        for (Iterator<Map.Entry<K, V>> iterator = cache.iterator(); iterator.hasNext(); ) {
            entry = iterator.next();
            key = entry.getKey();
            if (pattern.matcher(toKeyString(key)).find()) {
                generator.writeStartObject();
                generator.writeFieldName(KEY);
                writeKey(writer, key);
                generator.writeFieldName(VALUE);
                writeValue(writer, entry.getValue());
                generator.writeEndObject();
                if (removeIfMatched) {
                    iterator.remove();
                }
            }
        }
        generator.writeEndArray();
        generator.flush();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void read(Cache<K, V> cache, InputStream inputStream) throws Exception {
        JsonParser parser =
                jsonFactory.createJsonParser(new InputStreamReader(inputStream, CHARSET));
        JsonToken token = parser.nextToken();
        JsonToken endToken = (token == JsonToken.START_ARRAY) ? JsonToken.END_ARRAY
                : ((token == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : null);
        if (endToken == null) {
            throw new IOException("first token is " + token + ", must be "
                    + JsonToken.START_ARRAY + " or " + JsonToken.START_OBJECT);
        }
        JsonReader reader = new JsonReader(parser);
        K key = null;
        V value = null;
        while ((token = parser.nextToken()) != endToken) {
            switch (token) {
                case FIELD_NAME:
                    String name = parser.getCurrentName();
                    if (KEY.equals(name)) {
                        parser.nextToken();
                        key = readKey(reader);
                    } else if (VALUE.equals(name)) {
                        parser.nextToken();
                        value = readValue(reader);
                    }
                    break;
                case END_OBJECT:
                    if (key != null && value != null) {
                        cache.put(key, value);
                    }
                    key = null;
                    value = null;
                    break;
            }
        }
        if (key != null && value != null) {
            cache.put(key, value);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void delete(String key, Cache<K, V> cache, OutputStream outputStream) throws Exception {
        K k = toKey(key);
        write(k, cache.remove(k), outputStream);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void delete(Pattern pattern, Cache<K, V> cache, OutputStream outputStream) throws Exception {
        write(pattern, cache, outputStream, true);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void delete(Cache<K, V> cache, InputStream inputStream) throws Exception {
        JsonParser parser =
                jsonFactory.createJsonParser(new InputStreamReader(inputStream, CHARSET));
        JsonToken token = parser.nextToken();
        JsonToken endToken = (token == JsonToken.START_ARRAY) ? JsonToken.END_ARRAY
                : ((token == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : null);
        if (endToken == null) {
            throw new IOException("first token is " + token + ", must be "
                    + JsonToken.START_ARRAY + " or " + JsonToken.START_OBJECT);
        }
        JsonReader reader = new JsonReader(parser);
        K key;
        while ((token = parser.nextToken()) != endToken) {
            if (token == JsonToken.FIELD_NAME) {
                String name = parser.getCurrentName();
                if (KEY.equals(name)) {
                    parser.nextToken();
                    key = readKey(reader);
                    cache.delete(key);
                }
            }
        }
    }

    /**
     * Writes a {@code K} key held by a cache into a specified {@code writer}.
     * This method is applied to all of the keys that written into a stream by this class.
     *
     * @param writer a writer that writes the {@code key} to a stream
     * @param key a {@code K} key to be written
     * @throws Exception if some error occurs
     */
    abstract protected void writeKey(JsonWriter writer, K key) throws Exception;

    /**
     * Writes a {@code V} value held by a cache into a specified {@code writer}.
     * This method is applied to all of the values that written into a stream by this class.
     *
     * @param writer a writer that writes the {@code key} to a stream
     * @param value a {@code V} value to be written
     * @throws Exception if some error occurs
     */
    abstract protected void writeValue(JsonWriter writer, V value) throws Exception;

    /**
     * Reads a {@code K} key from a specified {@code reader} that is to be written into a cache.
     * This method is applied to all of the keys that read from a stream by this class.
     *
     * @param reader a reader that read the {@code key} from a stream
     * @return the {@code K} key to be read from
     * @throws Exception if some error occurs
     */
    abstract protected K readKey(JsonReader reader) throws Exception;

    /**
     * Reads a {@code V} value from a specified {@code reader} that is to be written into a cache.
     * This method is applied to all of the keys that read from a stream by this class.
     *
     * @param reader a reader that read the {@code key} from a stream
     * @return the {@code V} value to be read from
     * @throws Exception
     */
    abstract protected V readValue(JsonReader reader) throws Exception;

    /**
     * Converts a {@code K} key into a string to be match with a regular expression by patter match reading.
     *
     * @param key a {@code K} to be converted into a string
     * @return the string value
     * @throws Exception if some error occurs
     */
    abstract protected String toKeyString(K key) throws Exception;

    /**
     * Converts a string key into a {@code K} key. A string expression key in a query is converted into
     * the type {@code K} by this method.
     *
     * @param key a string expression key in a query
     * @return the {@code K} key
     * @throws Exception if some error occures
     */
    abstract protected K toKey(String key) throws Exception;

    /**
     * Converts specified Java values into JSON values and write values into an associated stream with this class.
     */
    protected static class JsonWriter {

        /** an output stream provided by Jackson */
        private JsonGenerator generator;

        /**
         * Constructs a new {@code JsonWriter}.
         * @param generator an output stream provided by Jackson
         */
        JsonWriter(JsonGenerator generator) {
            this.generator = generator;
        }

        /**
         * Writes a byte array into the JSON stream.
         *
         * @param bytes a byte array to be written
         * @param offset a written offset of the {@code bytes}
         * @param length a written length of the {@code bytes}
         * @throws Exception if the {@code bytes} is not written with failure
         */
        public void writeBytes(byte[] bytes, int offset, int length) throws Exception {
            generator.writeBinary(bytes, offset, length);
        }

        /**
         * Writes a boolean value into the JSON stream.
         *
         * @param value a boolean value to be written
         * @throws Exception if the {@code bytes} is not written with failure
         */
        public void writeBoolean(boolean value) throws Exception {
            generator.writeBoolean(value);
        }

        /**
         * Writes a {@code BigDecimal} number into the JSON stream.
         *
         * @param value a BigDecimal value to be written
         * @throws Exception if the {@code value} is not written with failure
         */
        public void setNumber(BigDecimal value) throws Exception {
            if (value == null) {
                throw new NullPointerException();
            }
            generator.writeNumber(value);
        }

        /**
         * Writes a {@code BigInteger} number into the JSON stream.
         *
         * @param value a BigInteger value to be written
         * @throws Exception if the {@code value} is not written with failure
         */
        public void setNumber(BigInteger value) throws Exception {
            if (value == null) {
                throw new NullPointerException();
            }
            generator.writeNumber(value);
        }

        /**
         * Writes a {@code double} number into the JSON stream.
         *
         * @param value a double value to be written
         * @throws Exception if the {@code value} is not written with failure
         */
        public void setNumber(double value) throws Exception {
            generator.writeNumber(value);
        }

        /**
         * Writes a {@code float} number into the JSON stream.
         *
         * @param value a float value to be written
         * @throws Exception if the {@code value} is not written with failure
         */
        public void setNumber(float value) throws Exception {
            generator.writeNumber(value);
        }

        /**
         * Writes a {@code int} number into the JSON stream.
         *
         * @param value a int value to be written
         * @throws Exception if the {@code value} is not written with failure
         */
        public void setNumber(int value) throws Exception {
            generator.writeNumber(value);
        }

        /**
         * Writes a {@code long} number into the JSON stream.
         *
         * @param value a long value to be written
         * @throws Exception if the {@code value} is not written with failure
         */
        public void setNumber(long value) throws Exception {
            generator.writeNumber(value);
        }

        /**
         * Writes an object into the JSON stream. The {@code object} must be serializable.
         *
         * @param object an object to be written
         * @throws Exception if the {@code object} is not written with failure
         */
        public void setObject(Object object) throws Exception {
            if (object == null) {
                throw new NullPointerException();
            }
            generator.writeObject(object);
        }

        /**
         * Writes a {@code String} value into the JSON stream.
         *
         * @param value a string to be written
         * @throws Exception if the {@code value} is not written with failure
         */
        public void setString(String value) throws Exception {
            if (value == null) {
                throw new NullPointerException();
            }
            generator.writeString(value);
        }
    }

    /**
     * Read values from an associated stream with this class and converts JSON values into Java values.
     */
    protected static class JsonReader {

        /** an input stream provided by Jackson */
        private JsonParser parser;

        /**
         * Constructs a new {@cde JsonReader}.
         *
         * @param parser an input stream provided by Jackson
         */
        JsonReader(JsonParser parser) {
            this.parser = parser;
        }

        /**
         * Reads a byte array from the JSON stream.
         *
         * @return the byte array
         * @throws Exception if the value is not read with failure
         */
        public byte[] readBytes() throws Exception {
            return parser.getBinaryValue();
        }

        /**
         * Reads {@code boolean} value from the JSON stream.
         *
         * @return the {@code boolean} value
         * @throws Exception if the value is not read with failure
         */
        public boolean readBoolean() throws Exception {
            return parser.getBooleanValue();
        }

        /**
         * Reads {@code BigDecimal} value from the JSON stream.
         *
         * @return the {@code BigDecimal} value
         * @throws Exception if the value is not read with failure
         */
        public BigDecimal readBigDecimal() throws Exception {
            return parser.getDecimalValue();
        }

        /**
         * Reads {@code BigInteger} value from the JSON stream.
         *
         * @return the {@code BigInteger} value
         * @throws Exception if the value is not read with failure
         */
        public BigInteger getBigInteger() throws Exception {
            return parser.getBigIntegerValue();
        }

        /**
         * Reads {@code double} value from the JSON stream.
         *
         * @return the {@code double} value
         * @throws Exception if the value is not read with failure
         */
        public double getDouble() throws Exception {
            return parser.getDoubleValue();
        }

        /**
         * Reads {@code float} value from the JSON stream.
         *
         * @return the {@code float} value
         * @throws Exception if the value is not read with failure
         */
        public float getFloat() throws Exception {
            return parser.getFloatValue();
        }

        /**
         * Reads {@code int} value from the JSON stream.
         *
         * @return the {@code int} value
         * @throws Exception if the value is not read with failure
         */
        public int getInt() throws Exception {
            return parser.getIntValue();
        }

        /**
         * Reads {@code long} value from the JSON stream.
         *
         * @return the {@code long} value
         * @throws Exception if the value is not read with failure
         */
        public long getLong() throws Exception {
            return parser.getLongValue();
        }

        /**
         * Reads an object from the JSON stream.
         *
         * @return the object
         * @throws Exception if the value is not read with failure
         */
        public Object getObject() throws Exception {
            return parser.getEmbeddedObject();
        }

        /**
         * Reads {@code String} value from the JSON stream.
         *
         * @return the {@code String} value
         * @throws Exception if the value is not read with failure
         */
        public String getString() throws Exception {
            return parser.getText();
        }
    }
}
