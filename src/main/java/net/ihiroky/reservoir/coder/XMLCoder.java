package net.ihiroky.reservoir.coder;

import net.ihiroky.reservoir.Cache;
import net.ihiroky.reservoir.StreamingCoder;

import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamReader;
import javax.xml.stream.XMLStreamWriter;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * A base implementation of {@link net.ihiroky.reservoir.StreamingCoder} to handle with xml.
 * The xml format generated by {@code XMLCoder}, follows listed below, for a cache,
 * {@code kn} is a key in the cache and {@code kv} is a mapped value for {@code kn}:
 *
 * <pre>
 *     <?xml version="1.0" encoding="UTF-8"?>
 *     <entries>
 *         <entry key="k1">v1</entry>
 *         <entry key="k2">v2</entry>
 *         ...
 *         <entry key="kn">vn</entry>
 *     </entries>
 * </pre>
 *
 * The actual xml is not pretty, which has no spaces and line feed between elements.
 * Supported charset is UTF-8 only.
 *
 * @param <K> the type of keys
 * @param <V> the type of mapped values
 * @author Hiroki Itoh
 */
public abstract class XMLCoder<K, V> implements StreamingCoder<K, V> {

    private XMLOutputFactory outputFactory;
    private XMLInputFactory inputFactory;

    private static final Charset CHARSET = Charset.forName("UTF-8");
    private static final String XML_VERSION = "1.0";

    private static final String ELEMENT_OUTER = "entries";
    private static final String ELEMENT_INNER = "entry";
    private static final String ATTRIBUTE_KEY = "key";

    private static final XMLCoder<String, String> STRING_CODER = new XMLCoder<String, String>() {
        @Override
        protected String toKeyString(String key) {
            return key;
        }

        @Override
        protected String toValueString(String value) {
            return value;
        }

        @Override
        protected String toKey(String key) {
            return key;
        }

        @Override
        protected String toValue(String value) {
            return value;
        }
    };

    /**
     * Returns {@code XMLCoder} that codes a cache which type of the key and value are {@code String}.
     *
     * @return {@code XMLCoder} that codes a cache which type of the key and value are {@code String}
     */
    public static XMLCoder<String, String> getStringCoder() {
        return STRING_CODER;
    }

    /**
     * Constructs a new {@code XMLCoder}.
     */
    public XMLCoder() {
        outputFactory = XMLOutputFactory.newInstance();
        inputFactory = XMLInputFactory.newInstance();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void write(String key, Cache<K, V> cache, OutputStream outputStream) throws Exception {
        K k = toKey(key);
        write(k, cache.get(k), outputStream);
    }

    /**
     * Writes {@code key} and {@code value} into an {@code outputStream} with xml format.
     *
     * @param key a key of an entry
     * @param value a value of an entry
     * @param outputStream stream that the {@code key} and {@code value} are written into
     * @throws Exception if the {@code outputStream}
     */
    private void write(K key, V value, OutputStream outputStream) throws Exception {
        XMLStreamWriter writer = outputFactory.createXMLStreamWriter(
                new OutputStreamWriter(outputStream, CHARSET));
        writer.writeStartDocument(CHARSET.toString(), XML_VERSION);
        writer.writeStartElement(ELEMENT_OUTER);
        if (value != null) {
            writer.writeStartElement(ELEMENT_INNER);
            writer.writeAttribute(ATTRIBUTE_KEY, toKeyString(key));
            writer.writeCharacters(toValueString(value));
            writer.writeEndElement();
        }
        writer.writeEndElement();
        writer.writeEndDocument();
        writer.flush();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void write(Pattern pattern, Cache<K, V> cache, OutputStream outputStream) throws Exception {
        write(pattern, cache, outputStream, false);
    }

    /**
     * Writes keys that is matched by a regular expression and the mapped {@code value}s
     * to a specified {@code outputStream}.
     *
     * @param pattern a regular expression which matches keys to be written
     * @param cache a cache that holds keys matched by {@code pattern} and mapped value by the keys
     * @param outputStream a stream witch matched keys and the mapped value are written into
     * @param removeIfMatched true if entries that have matched keys is delete from the {@code cache}
     * @throws Exception if some error occurs
     */
    private void write(Pattern pattern, Cache<K, V> cache, OutputStream outputStream,
                       boolean removeIfMatched) throws Exception {
        XMLStreamWriter writer = outputFactory.createXMLStreamWriter(
                new OutputStreamWriter(outputStream, CHARSET));
        writer.writeStartDocument(CHARSET.toString(), XML_VERSION);
        writer.writeStartElement(ELEMENT_OUTER);
        Map.Entry<K, V> entry;
        for (Iterator<Map.Entry<K, V>> iterator = cache.iterator(); iterator.hasNext(); ) {
            entry = iterator.next();
            String keyString = toKeyString(entry.getKey());
            if (pattern.matcher(keyString).find()) {
                writer.writeStartElement(ELEMENT_INNER);
                writer.writeAttribute(ATTRIBUTE_KEY, keyString);
                writer.writeCharacters(toValueString(entry.getValue()));
                writer.writeEndElement();
                if (removeIfMatched) {
                    iterator.remove();
                }
            }
        }
        writer.writeEndElement();
        writer.writeEndDocument();
        writer.flush();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void read(Cache<K, V> cache, InputStream inputStream) throws Exception {
        XMLStreamReader reader = inputFactory.createXMLStreamReader(
                new InputStreamReader(inputStream, CHARSET));
        K key = null;
        StringBuilder valueBuilder = new StringBuilder();
        LOOP:
        while (reader.hasNext()) {
            switch (reader.next()) {
                case XMLStreamReader.START_ELEMENT: {
                    String localName = reader.getLocalName();
                    if (!ELEMENT_INNER.equals(localName)) {
                        continue LOOP;
                    }
                    key = parseKey(reader);
                }
                break;
                case XMLStreamReader.CHARACTERS:
                    if (key != null) {
                        valueBuilder.append(reader.getText());
                    }
                    break;
                case XMLStreamReader.END_ELEMENT: {
                    String localName = reader.getLocalName();
                    if (!ELEMENT_INNER.equals(localName)) {
                        continue LOOP;
                    }
                    V value = toValue(valueBuilder.toString());
                    if (key != null && value != null) {
                        cache.put(key, value);
                        key = null;
                        valueBuilder = new StringBuilder();
                    }
                }
                break;
            }
        }
    }

    /**
     * Reads a {@code K} key from a specified {@code reader} that is to be written into a cache.
     * This method is applied to all of the keys that read from a stream by this class.
     *
     * @param reader a reader that read the {@code key} from a stream
     * @return the {@code K} key to be read from
     * @throws Exception if some error occurs
     */
    private K parseKey(XMLStreamReader reader) throws Exception {
        int attrCount = reader.getAttributeCount();
        String attrName;
        for (int i = 0; i < attrCount; i++) {
            attrName = reader.getAttributeLocalName(i);
            if (ATTRIBUTE_KEY.equals(attrName)) {
                return toKey(reader.getAttributeValue(i));
            }
        }
        return null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void delete(String key, Cache<K, V> cache, OutputStream outputStream) throws Exception {
        K k = toKey(key);
        write(k, cache.remove(k), outputStream);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void delete(Pattern pattern, Cache<K, V> cache, OutputStream outputStream) throws Exception {
        write(pattern, cache, outputStream, true);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void delete(Cache<K, V> cache, InputStream inputStream) throws Exception {
        XMLStreamReader reader = inputFactory.createXMLStreamReader(
                new InputStreamReader(inputStream, CHARSET));
        K key = null;
        LOOP:
        while (reader.hasNext()) {
            switch (reader.next()) {
                case XMLStreamReader.START_ELEMENT: {
                    String localName = reader.getLocalName();
                    if (!ELEMENT_INNER.equals(localName)) {
                        continue LOOP;
                    }
                    key = parseKey(reader);
                }
                break;
                case XMLStreamReader.END_ELEMENT: {
                    String localName = reader.getLocalName();
                    if (!ELEMENT_INNER.equals(localName)) {
                        continue LOOP;
                    }
                    if (key != null) {
                        cache.delete(key);
                        key = null;
                    }
                }
                break;
            }
        }
    }

    /**
     * Returns a string expression for a specified {@code key}. All of the keys written into xml
     * is converted by this method.
     *
     * @param key a key to be converted
     * @return the string for the {@code key}
     */
    abstract protected String toKeyString(K key);

    /**
     * Returns a string expression for a specified {@code value}. All of the values written into xml
     * is converted by this method.
     *
     * @param value a value to be converted
     * @return the string for the {@code value}
     */
    abstract protected String toValueString(V value);

    /**
     * Converts a string into a key of type {@code K} in a cache. All of the keys read from xml
     * is converted by this method.
     *
     * @param key a string to be converted
     * @return the type {@code K} key in a cache
     */
    abstract protected K toKey(String key);

    /**
     * Converts a string into a value of type {@code K} in a cache. All of the values read from xml
     * is converted by this method.
     *
     * @param value a string to be converted
     * @return the type {@code V} value in a cache
     */
    abstract protected V toValue(String value);
}
